#!/usr/bin/env bash
# vim: set ft=sh

set -e -o pipefail

exec 3>&1
exec 1>&2

cd "${1}"

payload=$(mktemp /tmp/resource.XXXXXX)
cat > ${payload} <&0

# source
bitbucket_type=`jq -r '.source.bitbucket_type // "server"' < ${payload}`
base_url=`jq -r '.source.base_url // ""' < ${payload}`
username=`jq -r '.source.username // ""' < ${payload}`
password=`jq -r '.source.password // ""' < ${payload}`
project=`jq -r '.source.project // ""' < ${payload}`
repository=`jq -r '.source.repository // ""' < ${payload}`
limit=`jq -r '.source.limit // 100' < ${payload}`
# version
version_updated_at=`jq -r '.version.updated_at // 0' < ${payload}`

if [[ ! ${base_url} ]]; then
    echo "error: source.base_url can't be empty"
    exit 1
fi
if [[ ! ${project} ]]; then
    echo "error: source.project can't be empty"
    exit 1
fi
if [[ ! ${repository} ]]; then
    echo "error: source.repository can't be empty"
    exit 1
fi

# Bitbucket Cloud and (self-hosted) Server APIs are a bit different
if [[ "$bitbucket_type" == "server" ]]; then
    uri="${base_url}/rest/api/1.0/projects/${project}/repos/${repository}/pull-requests?limit=${limit}&state=open"

    curl -s --fail -u ${username}:${password} $uri | jq -r \
        '.values
        | map({
            id: .id | tostring, 
            branch: .fromRef.id | tostring | (capture("refs/heads/(?<branch>.+)").branch // .),
            commit: .fromRef.latestCommit, 
            updated_at: .updatedDate | tostring
        }) 
        | map(select(.updated_at >= '$version_updated_at'))
        | sort_by(.updated_at)' >&3
elif [[ "$bitbucket_type" == "cloud" ]]; then
    uri="${base_url}/api/2.0/repositories/${project}/${repository}/pullrequests?limit=${limit}&state=open"

    curl -s --fail -u ${username}:${password} $uri | jq -r \
        '.values
        | map({
            id: .id | tostring, 
            branch: .source.branch.name | tostring,
            commit: .source.commit.hash, 
            updated_at: .updated_on | tostring
        }) 
        | map(select(.updated_at >= "$version_updated_at"))
        | sort_by(.updated_at)' >&3
fi

